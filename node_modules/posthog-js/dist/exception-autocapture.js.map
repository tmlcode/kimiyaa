{"version":3,"file":"exception-autocapture.js","sources":["../src/utils/globals.ts","../../core/dist/utils/type-utils.mjs","../../core/dist/utils/index.mjs","../../core/dist/error-tracking/chunk-ids.mjs","../../core/dist/error-tracking/error-properties-builder.mjs","../../core/dist/error-tracking/parsers/base.mjs","../../core/dist/error-tracking/parsers/safari.mjs","../../core/dist/error-tracking/parsers/chrome.mjs","../../core/dist/error-tracking/parsers/gecko.mjs","../../core/dist/error-tracking/parsers/index.mjs","../../core/dist/error-tracking/coercers/dom-exception-coercer.mjs","../../core/dist/error-tracking/coercers/error-coercer.mjs","../../core/dist/error-tracking/coercers/error-event-coercer.mjs","../../core/dist/error-tracking/coercers/string-coercer.mjs","../../core/dist/error-tracking/types.mjs","../../core/dist/error-tracking/coercers/utils.mjs","../../core/dist/error-tracking/coercers/object-coercer.mjs","../../core/dist/error-tracking/coercers/event-coercer.mjs","../../core/dist/error-tracking/coercers/primitive-coercer.mjs","../../core/dist/error-tracking/coercers/promise-rejection-event.mjs","../src/utils/logger.ts","../src/request.ts","../src/posthog-exceptions.ts","../src/entrypoints/exception-autocapture.ts"],"sourcesContent":["import type { PostHog } from '../posthog-core'\nimport { SessionIdManager } from '../sessionid'\nimport {\n    DeadClicksAutoCaptureConfig,\n    ExternalIntegrationKind,\n    Properties,\n    RemoteConfig,\n    SiteAppLoader,\n    SessionStartReason,\n} from '../types'\nimport type { ConversationsRemoteConfig } from '../posthog-conversations-types'\n// only importing types here, so won't affect the bundle\n// eslint-disable-next-line posthog-js/no-external-replay-imports\nimport type { SessionRecordingStatus, TriggerType } from '../extensions/replay/external/triggerMatching'\nimport { eventWithTime } from '../extensions/replay/types/rrweb-types'\nimport { ErrorTracking } from '@posthog/core'\n\n/*\n * Global helpers to protect access to browser globals in a way that is safer for different targets\n * like DOM, SSR, Web workers etc.\n *\n * NOTE: Typically we want the \"window\" but globalThis works for both the typical browser context as\n * well as other contexts such as the web worker context. Window is still exported for any bits that explicitly require it.\n * If in doubt - export the global you need from this file and use that as an optional value. This way the code path is forced\n * to handle the case where the global is not available.\n */\n\n// eslint-disable-next-line no-restricted-globals\nconst win: (Window & typeof globalThis) | undefined = typeof window !== 'undefined' ? window : undefined\n\nexport type AssignableWindow = Window &\n    typeof globalThis & {\n        /*\n         * Main PostHog instance\n         */\n        posthog: any\n\n        /*\n         * This is our contract between (potentially) lazily loaded extensions and the SDK\n         */\n        __PosthogExtensions__?: PostHogExtensions\n\n        /**\n         * When loading remote config, we assign it to this global configuration\n         * for ease of sharing it with the rest of the SDK\n         */\n        _POSTHOG_REMOTE_CONFIG?: Record<\n            string,\n            {\n                config: RemoteConfig\n                siteApps: SiteAppLoader[]\n            }\n        >\n\n        /**\n         * If this is set on the window, our logger will log to the console\n         * for ease of debugging. Used for testing purposes only.\n         *\n         * @see {Config.DEBUG} from config.ts\n         */\n        POSTHOG_DEBUG: any\n\n        // Exposed by the browser\n        doNotTrack: any\n\n        // See entrypoints/customizations.full.ts\n        posthogCustomizations: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/exception-autocapture.ts\n         *\n         * @deprecated use `__PosthogExtensions__.errorWrappingFunctions` instead\n         */\n        posthogErrorWrappingFunctions: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrweb` instead\n         */\n        rrweb: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.rrwebConsoleRecord` instead\n         */\n        rrwebConsoleRecord: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/posthog-recorder.ts\n         *\n         * @deprecated use `__PosthogExtensions__.getRecordNetworkPlugin` instead\n         */\n        getRecordNetworkPlugin: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/web-vitals.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogWebVitalsCallbacks` instead\n         */\n        postHogWebVitalsCallbacks: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/tracing-headers.ts\n         *\n         * @deprecated use `__PosthogExtensions__.postHogTracingHeadersPatchFns` instead\n         */\n        postHogTracingHeadersPatchFns: any\n\n        /**\n         * This is a legacy way to expose these functions, but we still need to support it for backwards compatibility\n         * Can be removed once we drop support for 1.161.1\n         *\n         * See entrypoints/surveys.ts\n         *\n         * @deprecated use `__PosthogExtensions__.generateSurveys` instead\n         */\n        extendPostHogWithSurveys: any\n\n        /*\n         * These are used to handle our toolbar state.\n         * @see {Toolbar} from extensions/toolbar.ts\n         */\n        ph_load_toolbar: any\n        ph_load_editor: any\n        ph_toolbar_state: any\n    } & Record<`__$$ph_site_app_${string}`, any>\n\n/**\n * This is our contract between (potentially) lazily loaded extensions and the SDK\n * changes to this interface can be breaking changes for users of the SDK\n */\n\nexport type ExternalExtensionKind = 'intercom-integration' | 'crisp-chat-integration'\n\nexport type PostHogExtensionKind =\n    | 'toolbar'\n    | 'exception-autocapture'\n    | 'web-vitals'\n    | 'recorder'\n    | 'lazy-recorder'\n    | 'tracing-headers'\n    | 'surveys'\n    | 'conversations'\n    | 'product-tours'\n    | 'dead-clicks-autocapture'\n    | 'remote-config'\n    | ExternalExtensionKind\n\nexport interface LazyLoadedSessionRecordingInterface {\n    start: (startReason?: SessionStartReason) => void\n    stop: () => void\n    sessionId: string\n    status: SessionRecordingStatus\n    onRRwebEmit: (rawEvent: eventWithTime) => void\n    log: (message: string, level: 'log' | 'warn' | 'error') => void\n    sdkDebugProperties: Properties\n    overrideLinkedFlag: () => void\n    overrideSampling: () => void\n    overrideTrigger: (triggerType: TriggerType) => void\n    isStarted: boolean\n    tryAddCustomEvent(tag: string, payload: any): boolean\n}\n\nexport interface LazyLoadedDeadClicksAutocaptureInterface {\n    start: (observerTarget: Node) => void\n    stop: () => void\n}\n\nexport interface LazyLoadedConversationsInterface {\n    enable: () => void\n    disable: () => void\n    destroy: () => void\n    reset: () => void\n}\n\ninterface PostHogExtensions {\n    loadExternalDependency?: (\n        posthog: PostHog,\n        kind: PostHogExtensionKind,\n        callback: (error?: string | Event, event?: Event) => void\n    ) => void\n\n    loadSiteApp?: (posthog: PostHog, appUrl: string, callback: (error?: string | Event, event?: Event) => void) => void\n\n    errorWrappingFunctions?: {\n        wrapOnError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapUnhandledRejection: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n        wrapConsoleError: (captureFn: (props: ErrorTracking.ErrorProperties) => void) => () => void\n    }\n    rrweb?: { record: any; version: string }\n    rrwebPlugins?: { getRecordConsolePlugin: any; getRecordNetworkPlugin?: any }\n    generateSurveys?: (posthog: PostHog, isSurveysEnabled: boolean) => any | undefined\n    generateProductTours?: (posthog: PostHog, isEnabled: boolean) => any | undefined\n    postHogWebVitalsCallbacks?: {\n        onLCP: (metric: any) => void\n        onCLS: (metric: any) => void\n        onFCP: (metric: any) => void\n        onINP: (metric: any) => void\n    }\n    tracingHeadersPatchFns?: {\n        _patchFetch: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n        _patchXHR: (hostnames: string[], distinctId: string, sessionManager?: SessionIdManager) => () => void\n    }\n    initDeadClicksAutocapture?: (\n        ph: PostHog,\n        config: DeadClicksAutoCaptureConfig\n    ) => LazyLoadedDeadClicksAutocaptureInterface\n    integrations?: {\n        [K in ExternalIntegrationKind]?: { start: (posthog: PostHog) => void; stop: () => void }\n    }\n    initSessionRecording?: (ph: PostHog) => LazyLoadedSessionRecordingInterface\n    initConversations?: (config: ConversationsRemoteConfig, posthog: PostHog) => LazyLoadedConversationsInterface\n}\n\nconst global: typeof globalThis | undefined = typeof globalThis !== 'undefined' ? globalThis : win\n\n// React Native polyfills for posthog-js compatibility\nif (typeof self === 'undefined') {\n    ;(global as any).self = global\n}\nif (typeof File === 'undefined') {\n    ;(global as any).File = function () {}\n}\n\nexport const ArrayProto = Array.prototype\nexport const nativeForEach = ArrayProto.forEach\nexport const nativeIndexOf = ArrayProto.indexOf\n\nexport const navigator = global?.navigator\nexport const document = global?.document\nexport const location = global?.location\nexport const fetch = global?.fetch\nexport const XMLHttpRequest =\n    global?.XMLHttpRequest && 'withCredentials' in new global.XMLHttpRequest() ? global.XMLHttpRequest : undefined\nexport const AbortController = global?.AbortController\nexport const userAgent = navigator?.userAgent\nexport const assignableWindow: AssignableWindow = win ?? ({} as any)\n\nexport { win as window }\n","import { knownUnsafeEditableEvent } from \"../types.mjs\";\nimport { includes } from \"./string-utils.mjs\";\nconst nativeIsArray = Array.isArray;\nconst ObjProto = Object.prototype;\nconst type_utils_hasOwnProperty = ObjProto.hasOwnProperty;\nconst type_utils_toString = ObjProto.toString;\nconst isArray = nativeIsArray || function(obj) {\n    return '[object Array]' === type_utils_toString.call(obj);\n};\nconst isFunction = (x)=>'function' == typeof x;\nconst isNativeFunction = (x)=>isFunction(x) && -1 !== x.toString().indexOf('[native code]');\nconst isObject = (x)=>x === Object(x) && !isArray(x);\nconst isEmptyObject = (x)=>{\n    if (isObject(x)) {\n        for(const key in x)if (type_utils_hasOwnProperty.call(x, key)) return false;\n        return true;\n    }\n    return false;\n};\nconst isUndefined = (x)=>void 0 === x;\nconst isString = (x)=>'[object String]' == type_utils_toString.call(x);\nconst isEmptyString = (x)=>isString(x) && 0 === x.trim().length;\nconst isNull = (x)=>null === x;\nconst isNullish = (x)=>isUndefined(x) || isNull(x);\nconst isNumber = (x)=>'[object Number]' == type_utils_toString.call(x);\nconst isBoolean = (x)=>'[object Boolean]' === type_utils_toString.call(x);\nconst isFormData = (x)=>x instanceof FormData;\nconst isFile = (x)=>x instanceof File;\nconst isPlainError = (x)=>x instanceof Error;\nconst isKnownUnsafeEditableEvent = (x)=>includes(knownUnsafeEditableEvent, x);\nfunction isInstanceOf(candidate, base) {\n    try {\n        return candidate instanceof base;\n    } catch  {\n        return false;\n    }\n}\nfunction isPrimitive(value) {\n    return null === value || 'object' != typeof value;\n}\nfunction isBuiltin(candidate, className) {\n    return Object.prototype.toString.call(candidate) === `[object ${className}]`;\n}\nfunction isError(candidate) {\n    switch(Object.prototype.toString.call(candidate)){\n        case '[object Error]':\n        case '[object Exception]':\n        case '[object DOMException]':\n        case '[object DOMError]':\n        case '[object WebAssembly.Exception]':\n            return true;\n        default:\n            return isInstanceOf(candidate, Error);\n    }\n}\nfunction isErrorEvent(event) {\n    return isBuiltin(event, 'ErrorEvent');\n}\nfunction isEvent(candidate) {\n    return !isUndefined(Event) && isInstanceOf(candidate, Event);\n}\nfunction isPlainObject(candidate) {\n    return isBuiltin(candidate, 'Object');\n}\nconst yesLikeValues = [\n    true,\n    'true',\n    1,\n    '1',\n    'yes'\n];\nconst isYesLike = (val)=>includes(yesLikeValues, val);\nconst noLikeValues = [\n    false,\n    'false',\n    0,\n    '0',\n    'no'\n];\nconst isNoLike = (val)=>includes(noLikeValues, val);\nexport { type_utils_hasOwnProperty as hasOwnProperty, isArray, isBoolean, isBuiltin, isEmptyObject, isEmptyString, isError, isErrorEvent, isEvent, isFile, isFormData, isFunction, isInstanceOf, isKnownUnsafeEditableEvent, isNativeFunction, isNoLike, isNull, isNullish, isNumber, isObject, isPlainError, isPlainObject, isPrimitive, isString, isUndefined, isYesLike, noLikeValues, yesLikeValues };\n","export * from \"./bot-detection.mjs\";\nexport * from \"./bucketed-rate-limiter.mjs\";\nexport * from \"./number-utils.mjs\";\nexport * from \"./string-utils.mjs\";\nexport * from \"./type-utils.mjs\";\nexport * from \"./promise-queue.mjs\";\nexport * from \"./logger.mjs\";\nexport * from \"./user-agent-utils.mjs\";\nconst STRING_FORMAT = 'utf8';\nfunction assert(truthyValue, message) {\n    if (!truthyValue || 'string' != typeof truthyValue || isEmpty(truthyValue)) throw new Error(message);\n}\nfunction isEmpty(truthyValue) {\n    if (0 === truthyValue.trim().length) return true;\n    return false;\n}\nfunction removeTrailingSlash(url) {\n    return url?.replace(/\\/+$/, '');\n}\nasync function retriable(fn, props) {\n    let lastError = null;\n    for(let i = 0; i < props.retryCount + 1; i++){\n        if (i > 0) await new Promise((r)=>setTimeout(r, props.retryDelay));\n        try {\n            const res = await fn();\n            return res;\n        } catch (e) {\n            lastError = e;\n            if (!props.retryCheck(e)) throw e;\n        }\n    }\n    throw lastError;\n}\nfunction currentTimestamp() {\n    return new Date().getTime();\n}\nfunction currentISOTime() {\n    return new Date().toISOString();\n}\nfunction safeSetTimeout(fn, timeout) {\n    const t = setTimeout(fn, timeout);\n    t?.unref && t?.unref();\n    return t;\n}\nconst isPromise = (obj)=>obj && 'function' == typeof obj.then;\nconst isError = (x)=>x instanceof Error;\nfunction getFetch() {\n    return 'undefined' != typeof fetch ? fetch : void 0 !== globalThis.fetch ? globalThis.fetch : void 0;\n}\nfunction allSettled(promises) {\n    return Promise.all(promises.map((p)=>(p ?? Promise.resolve()).then((value)=>({\n                status: 'fulfilled',\n                value\n            }), (reason)=>({\n                status: 'rejected',\n                reason\n            }))));\n}\nexport { STRING_FORMAT, allSettled, assert, currentISOTime, currentTimestamp, getFetch, isError, isPromise, removeTrailingSlash, retriable, safeSetTimeout };\n","let parsedStackResults;\nlet lastKeysCount;\nlet cachedFilenameChunkIds;\nfunction getFilenameToChunkIdMap(stackParser) {\n    const chunkIdMap = globalThis._posthogChunkIds;\n    if (!chunkIdMap) return;\n    const chunkIdKeys = Object.keys(chunkIdMap);\n    if (cachedFilenameChunkIds && chunkIdKeys.length === lastKeysCount) return cachedFilenameChunkIds;\n    lastKeysCount = chunkIdKeys.length;\n    cachedFilenameChunkIds = chunkIdKeys.reduce((acc, stackKey)=>{\n        if (!parsedStackResults) parsedStackResults = {};\n        const result = parsedStackResults[stackKey];\n        if (result) acc[result[0]] = result[1];\n        else {\n            const parsedStack = stackParser(stackKey);\n            for(let i = parsedStack.length - 1; i >= 0; i--){\n                const stackFrame = parsedStack[i];\n                const filename = stackFrame?.filename;\n                const chunkId = chunkIdMap[stackKey];\n                if (filename && chunkId) {\n                    acc[filename] = chunkId;\n                    parsedStackResults[stackKey] = [\n                        filename,\n                        chunkId\n                    ];\n                    break;\n                }\n            }\n        }\n        return acc;\n    }, {});\n    return cachedFilenameChunkIds;\n}\nexport { getFilenameToChunkIdMap };\n","import { isArray } from \"../utils/index.mjs\";\nimport { getFilenameToChunkIdMap } from \"./chunk-ids.mjs\";\nconst MAX_CAUSE_RECURSION = 4;\nclass ErrorPropertiesBuilder {\n    constructor(coercers, stackParser, modifiers = []){\n        this.coercers = coercers;\n        this.stackParser = stackParser;\n        this.modifiers = modifiers;\n    }\n    buildFromUnknown(input, hint = {}) {\n        const providedMechanism = hint && hint.mechanism;\n        const mechanism = providedMechanism || {\n            handled: true,\n            type: 'generic'\n        };\n        const coercingContext = this.buildCoercingContext(mechanism, hint, 0);\n        const exceptionWithCause = coercingContext.apply(input);\n        const parsingContext = this.buildParsingContext();\n        const exceptionWithStack = this.parseStacktrace(exceptionWithCause, parsingContext);\n        const exceptionList = this.convertToExceptionList(exceptionWithStack, mechanism);\n        return {\n            $exception_list: exceptionList,\n            $exception_level: 'error'\n        };\n    }\n    async modifyFrames(exceptionList) {\n        for (const exc of exceptionList)if (exc.stacktrace && exc.stacktrace.frames && isArray(exc.stacktrace.frames)) exc.stacktrace.frames = await this.applyModifiers(exc.stacktrace.frames);\n        return exceptionList;\n    }\n    coerceFallback(ctx) {\n        return {\n            type: 'Error',\n            value: 'Unknown error',\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n    parseStacktrace(err, ctx) {\n        let cause;\n        if (null != err.cause) cause = this.parseStacktrace(err.cause, ctx);\n        let stack;\n        if ('' != err.stack && null != err.stack) stack = this.applyChunkIds(this.stackParser(err.stack, err.synthetic ? 1 : 0), ctx.chunkIdMap);\n        return {\n            ...err,\n            cause,\n            stack\n        };\n    }\n    applyChunkIds(frames, chunkIdMap) {\n        return frames.map((frame)=>{\n            if (frame.filename && chunkIdMap) frame.chunk_id = chunkIdMap[frame.filename];\n            return frame;\n        });\n    }\n    applyCoercers(input, ctx) {\n        for (const adapter of this.coercers)if (adapter.match(input)) return adapter.coerce(input, ctx);\n        return this.coerceFallback(ctx);\n    }\n    async applyModifiers(frames) {\n        let newFrames = frames;\n        for (const modifier of this.modifiers)newFrames = await modifier(newFrames);\n        return newFrames;\n    }\n    convertToExceptionList(exceptionWithStack, mechanism) {\n        const currentException = {\n            type: exceptionWithStack.type,\n            value: exceptionWithStack.value,\n            mechanism: {\n                type: mechanism.type ?? 'generic',\n                handled: mechanism.handled ?? true,\n                synthetic: exceptionWithStack.synthetic ?? false\n            }\n        };\n        if (exceptionWithStack.stack) currentException.stacktrace = {\n            type: 'raw',\n            frames: exceptionWithStack.stack\n        };\n        const exceptionList = [\n            currentException\n        ];\n        if (null != exceptionWithStack.cause) exceptionList.push(...this.convertToExceptionList(exceptionWithStack.cause, {\n            ...mechanism,\n            handled: true\n        }));\n        return exceptionList;\n    }\n    buildParsingContext() {\n        const context = {\n            chunkIdMap: getFilenameToChunkIdMap(this.stackParser)\n        };\n        return context;\n    }\n    buildCoercingContext(mechanism, hint, depth = 0) {\n        const coerce = (input, depth)=>{\n            if (!(depth <= MAX_CAUSE_RECURSION)) return;\n            {\n                const ctx = this.buildCoercingContext(mechanism, hint, depth);\n                return this.applyCoercers(input, ctx);\n            }\n        };\n        const context = {\n            ...hint,\n            syntheticException: 0 == depth ? hint.syntheticException : void 0,\n            mechanism,\n            apply: (input)=>coerce(input, depth),\n            next: (input)=>coerce(input, depth + 1)\n        };\n        return context;\n    }\n}\nexport { ErrorPropertiesBuilder };\n","import { isUndefined } from \"../../utils/index.mjs\";\nconst UNKNOWN_FUNCTION = '?';\nfunction createFrame(platform, filename, func, lineno, colno) {\n    const frame = {\n        platform,\n        filename,\n        function: '<anonymous>' === func ? UNKNOWN_FUNCTION : func,\n        in_app: true\n    };\n    if (!isUndefined(lineno)) frame.lineno = lineno;\n    if (!isUndefined(colno)) frame.colno = colno;\n    return frame;\n}\nexport { UNKNOWN_FUNCTION, createFrame };\n","import { UNKNOWN_FUNCTION } from \"./base.mjs\";\nconst extractSafariExtensionDetails = (func, filename)=>{\n    const isSafariExtension = -1 !== func.indexOf('safari-extension');\n    const isSafariWebExtension = -1 !== func.indexOf('safari-web-extension');\n    return isSafariExtension || isSafariWebExtension ? [\n        -1 !== func.indexOf('@') ? func.split('@')[0] : UNKNOWN_FUNCTION,\n        isSafariExtension ? `safari-extension:${filename}` : `safari-web-extension:${filename}`\n    ] : [\n        func,\n        filename\n    ];\n};\nexport { extractSafariExtensionDetails };\n","import { UNKNOWN_FUNCTION, createFrame } from \"./base.mjs\";\nimport { extractSafariExtensionDetails } from \"./safari.mjs\";\nconst chromeRegexNoFnName = /^\\s*at (\\S+?)(?::(\\d+))(?::(\\d+))\\s*$/i;\nconst chromeRegex = /^\\s*at (?:(.+?\\)(?: \\[.+\\])?|.*?) ?\\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\\/)?.*?)(?::(\\d+))?(?::(\\d+))?\\)?\\s*$/i;\nconst chromeEvalRegex = /\\((\\S*)(?::(\\d+))(?::(\\d+))\\)/;\nconst chromeStackLineParser = (line, platform)=>{\n    const noFnParts = chromeRegexNoFnName.exec(line);\n    if (noFnParts) {\n        const [, filename, line, col] = noFnParts;\n        return createFrame(platform, filename, UNKNOWN_FUNCTION, +line, +col);\n    }\n    const parts = chromeRegex.exec(line);\n    if (parts) {\n        const isEval = parts[2] && 0 === parts[2].indexOf('eval');\n        if (isEval) {\n            const subMatch = chromeEvalRegex.exec(parts[2]);\n            if (subMatch) {\n                parts[2] = subMatch[1];\n                parts[3] = subMatch[2];\n                parts[4] = subMatch[3];\n            }\n        }\n        const [func, filename] = extractSafariExtensionDetails(parts[1] || UNKNOWN_FUNCTION, parts[2]);\n        return createFrame(platform, filename, func, parts[3] ? +parts[3] : void 0, parts[4] ? +parts[4] : void 0);\n    }\n};\nexport { chromeStackLineParser };\n","import { UNKNOWN_FUNCTION, createFrame } from \"./base.mjs\";\nimport { extractSafariExtensionDetails } from \"./safari.mjs\";\nconst geckoREgex = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)?((?:[-a-z]+)?:\\/.*?|\\[native code\\]|[^@]*(?:bundle|\\d+\\.js)|\\/[\\w\\-. /=]+)(?::(\\d+))?(?::(\\d+))?\\s*$/i;\nconst geckoEvalRegex = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nconst geckoStackLineParser = (line, platform)=>{\n    const parts = geckoREgex.exec(line);\n    if (parts) {\n        const isEval = parts[3] && parts[3].indexOf(' > eval') > -1;\n        if (isEval) {\n            const subMatch = geckoEvalRegex.exec(parts[3]);\n            if (subMatch) {\n                parts[1] = parts[1] || 'eval';\n                parts[3] = subMatch[1];\n                parts[4] = subMatch[2];\n                parts[5] = '';\n            }\n        }\n        let filename = parts[3];\n        let func = parts[1] || UNKNOWN_FUNCTION;\n        [func, filename] = extractSafariExtensionDetails(func, filename);\n        return createFrame(platform, filename, func, parts[4] ? +parts[4] : void 0, parts[5] ? +parts[5] : void 0);\n    }\n};\nexport { geckoStackLineParser };\n","import { UNKNOWN_FUNCTION } from \"./base.mjs\";\nimport { chromeStackLineParser } from \"./chrome.mjs\";\nimport { winjsStackLineParser } from \"./winjs.mjs\";\nimport { geckoStackLineParser } from \"./gecko.mjs\";\nimport { opera10StackLineParser, opera11StackLineParser } from \"./opera.mjs\";\nimport { nodeStackLineParser } from \"./node.mjs\";\nconst WEBPACK_ERROR_REGEXP = /\\(error: (.*)\\)/;\nconst STACKTRACE_FRAME_LIMIT = 50;\nfunction reverseAndStripFrames(stack) {\n    if (!stack.length) return [];\n    const localStack = Array.from(stack);\n    localStack.reverse();\n    return localStack.slice(0, STACKTRACE_FRAME_LIMIT).map((frame)=>({\n            ...frame,\n            filename: frame.filename || getLastStackFrame(localStack).filename,\n            function: frame.function || UNKNOWN_FUNCTION\n        }));\n}\nfunction getLastStackFrame(arr) {\n    return arr[arr.length - 1] || {};\n}\nfunction createStackParser(platform, ...parsers) {\n    return (stack, skipFirstLines = 0)=>{\n        const frames = [];\n        const lines = stack.split('\\n');\n        for(let i = skipFirstLines; i < lines.length; i++){\n            const line = lines[i];\n            if (line.length > 1024) continue;\n            const cleanedLine = WEBPACK_ERROR_REGEXP.test(line) ? line.replace(WEBPACK_ERROR_REGEXP, '$1') : line;\n            if (!cleanedLine.match(/\\S*Error: /)) {\n                for (const parser of parsers){\n                    const frame = parser(cleanedLine, platform);\n                    if (frame) {\n                        frames.push(frame);\n                        break;\n                    }\n                }\n                if (frames.length >= STACKTRACE_FRAME_LIMIT) break;\n            }\n        }\n        return reverseAndStripFrames(frames);\n    };\n}\nexport { chromeStackLineParser, createStackParser, geckoStackLineParser, nodeStackLineParser, opera10StackLineParser, opera11StackLineParser, reverseAndStripFrames, winjsStackLineParser };\n","import { isBuiltin, isString } from \"../../utils/index.mjs\";\nclass DOMExceptionCoercer {\n    match(err) {\n        return this.isDOMException(err) || this.isDOMError(err);\n    }\n    coerce(err, ctx) {\n        const hasStack = isString(err.stack);\n        return {\n            type: this.getType(err),\n            value: this.getValue(err),\n            stack: hasStack ? err.stack : void 0,\n            cause: err.cause ? ctx.next(err.cause) : void 0,\n            synthetic: false\n        };\n    }\n    getType(candidate) {\n        return this.isDOMError(candidate) ? 'DOMError' : 'DOMException';\n    }\n    getValue(err) {\n        const name = err.name || (this.isDOMError(err) ? 'DOMError' : 'DOMException');\n        const message = err.message ? `${name}: ${err.message}` : name;\n        return message;\n    }\n    isDOMException(err) {\n        return isBuiltin(err, 'DOMException');\n    }\n    isDOMError(err) {\n        return isBuiltin(err, 'DOMError');\n    }\n}\nexport { DOMExceptionCoercer };\n","import { isPlainError } from \"../../utils/index.mjs\";\nclass ErrorCoercer {\n    match(err) {\n        return isPlainError(err);\n    }\n    coerce(err, ctx) {\n        return {\n            type: this.getType(err),\n            value: this.getMessage(err, ctx),\n            stack: this.getStack(err),\n            cause: err.cause ? ctx.next(err.cause) : void 0,\n            synthetic: false\n        };\n    }\n    getType(err) {\n        return err.name || err.constructor.name;\n    }\n    getMessage(err, _ctx) {\n        const message = err.message;\n        if (message.error && 'string' == typeof message.error.message) return String(message.error.message);\n        return String(message);\n    }\n    getStack(err) {\n        return err.stacktrace || err.stack || void 0;\n    }\n}\nexport { ErrorCoercer };\n","import { isErrorEvent } from \"../../utils/index.mjs\";\nclass ErrorEventCoercer {\n    constructor(){}\n    match(err) {\n        return isErrorEvent(err) && void 0 != err.error;\n    }\n    coerce(err, ctx) {\n        const exceptionLike = ctx.apply(err.error);\n        if (!exceptionLike) return {\n            type: 'ErrorEvent',\n            value: err.message,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n        return exceptionLike;\n    }\n}\nexport { ErrorEventCoercer };\n","const ERROR_TYPES_PATTERN = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;\nclass StringCoercer {\n    match(input) {\n        return 'string' == typeof input;\n    }\n    coerce(input, ctx) {\n        const [type, value] = this.getInfos(input);\n        return {\n            type: type ?? 'Error',\n            value: value ?? input,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n    getInfos(candidate) {\n        let type = 'Error';\n        let value = candidate;\n        const groups = candidate.match(ERROR_TYPES_PATTERN);\n        if (groups) {\n            type = groups[1];\n            value = groups[2];\n        }\n        return [\n            type,\n            value\n        ];\n    }\n}\nexport { StringCoercer };\n","const severityLevels = [\n    'fatal',\n    'error',\n    'warning',\n    'log',\n    'info',\n    'debug'\n];\nexport { severityLevels };\n","function truncate(str, max = 0) {\n    if ('string' != typeof str || 0 === max) return str;\n    return str.length <= max ? str : `${str.slice(0, max)}...`;\n}\nfunction extractExceptionKeysForMessage(err, maxLength = 40) {\n    const keys = Object.keys(err);\n    keys.sort();\n    if (!keys.length) return '[object has no keys]';\n    for(let i = keys.length; i > 0; i--){\n        const serialized = keys.slice(0, i).join(', ');\n        if (!(serialized.length > maxLength)) {\n            if (i === keys.length) return serialized;\n            return serialized.length <= maxLength ? serialized : `${serialized.slice(0, maxLength)}...`;\n        }\n    }\n    return '';\n}\nexport { extractExceptionKeysForMessage, truncate };\n","import { isEmptyString, isError, isEvent, isString } from \"../../utils/index.mjs\";\nimport { severityLevels } from \"../types.mjs\";\nimport { extractExceptionKeysForMessage } from \"./utils.mjs\";\nclass ObjectCoercer {\n    match(candidate) {\n        return 'object' == typeof candidate && null !== candidate;\n    }\n    coerce(candidate, ctx) {\n        const errorProperty = this.getErrorPropertyFromObject(candidate);\n        if (errorProperty) return ctx.apply(errorProperty);\n        return {\n            type: this.getType(candidate),\n            value: this.getValue(candidate),\n            stack: ctx.syntheticException?.stack,\n            level: this.isSeverityLevel(candidate.level) ? candidate.level : 'error',\n            synthetic: true\n        };\n    }\n    getType(err) {\n        return isEvent(err) ? err.constructor.name : 'Error';\n    }\n    getValue(err) {\n        if ('name' in err && 'string' == typeof err.name) {\n            let message = `'${err.name}' captured as exception`;\n            if ('message' in err && 'string' == typeof err.message) message += ` with message: '${err.message}'`;\n            return message;\n        }\n        if ('message' in err && 'string' == typeof err.message) return err.message;\n        const className = this.getObjectClassName(err);\n        const keys = extractExceptionKeysForMessage(err);\n        return `${className && 'Object' !== className ? `'${className}'` : 'Object'} captured as exception with keys: ${keys}`;\n    }\n    isSeverityLevel(x) {\n        return isString(x) && !isEmptyString(x) && severityLevels.indexOf(x) >= 0;\n    }\n    getErrorPropertyFromObject(obj) {\n        for(const prop in obj)if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n            const value = obj[prop];\n            if (isError(value)) return value;\n        }\n    }\n    getObjectClassName(obj) {\n        try {\n            const prototype = Object.getPrototypeOf(obj);\n            return prototype ? prototype.constructor.name : void 0;\n        } catch (e) {\n            return;\n        }\n    }\n}\nexport { ObjectCoercer };\n","import { isEvent } from \"../../utils/index.mjs\";\nimport { extractExceptionKeysForMessage } from \"./utils.mjs\";\nclass EventCoercer {\n    match(err) {\n        return isEvent(err);\n    }\n    coerce(evt, ctx) {\n        const constructorName = evt.constructor.name;\n        return {\n            type: constructorName,\n            value: `${constructorName} captured as exception with keys: ${extractExceptionKeysForMessage(evt)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n}\nexport { EventCoercer };\n","import { isPrimitive } from \"../../utils/index.mjs\";\nclass PrimitiveCoercer {\n    match(candidate) {\n        return isPrimitive(candidate);\n    }\n    coerce(value, ctx) {\n        return {\n            type: 'Error',\n            value: `Primitive value captured as exception: ${String(value)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n    }\n}\nexport { PrimitiveCoercer };\n","import { isBuiltin, isPrimitive } from \"../../utils/index.mjs\";\nclass PromiseRejectionEventCoercer {\n    match(err) {\n        return isBuiltin(err, 'PromiseRejectionEvent');\n    }\n    coerce(err, ctx) {\n        const reason = this.getUnhandledRejectionReason(err);\n        if (isPrimitive(reason)) return {\n            type: 'UnhandledRejection',\n            value: `Non-Error promise rejection captured with value: ${String(reason)}`,\n            stack: ctx.syntheticException?.stack,\n            synthetic: true\n        };\n        return ctx.apply(reason);\n    }\n    getUnhandledRejectionReason(error) {\n        if (isPrimitive(error)) return error;\n        try {\n            if ('reason' in error) return error.reason;\n            if ('detail' in error && 'reason' in error.detail) return error.detail.reason;\n        } catch  {}\n        return error;\n    }\n}\nexport { PromiseRejectionEventCoercer };\n","import Config from '../config'\nimport { isUndefined } from '@posthog/core'\nimport { assignableWindow, window } from './globals'\nimport type { Logger } from '@posthog/core'\n\ntype CreateLoggerOptions = {\n    debugEnabled?: boolean\n}\n\ntype PosthogJsLogger = Omit<Logger, 'createLogger'> & {\n    _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => void\n    uninitializedWarning: (methodName: string) => void\n    createLogger: (prefix: string, options?: CreateLoggerOptions) => PosthogJsLogger\n}\n\nconst _createLogger = (prefix: string, { debugEnabled }: CreateLoggerOptions = {}): PosthogJsLogger => {\n    const logger: PosthogJsLogger = {\n        _log: (level: 'log' | 'warn' | 'error', ...args: any[]) => {\n            if (\n                window &&\n                (Config.DEBUG || assignableWindow.POSTHOG_DEBUG || debugEnabled) &&\n                !isUndefined(window.console) &&\n                window.console\n            ) {\n                const consoleLog =\n                    '__rrweb_original__' in window.console[level]\n                        ? (window.console[level] as any)['__rrweb_original__']\n                        : window.console[level]\n\n                // eslint-disable-next-line no-console\n                consoleLog(prefix, ...args)\n            }\n        },\n\n        info: (...args: any[]) => {\n            logger._log('log', ...args)\n        },\n\n        warn: (...args: any[]) => {\n            logger._log('warn', ...args)\n        },\n\n        error: (...args: any[]) => {\n            logger._log('error', ...args)\n        },\n\n        critical: (...args: any[]) => {\n            // Critical errors are always logged to the console\n            // eslint-disable-next-line no-console\n            console.error(prefix, ...args)\n        },\n\n        uninitializedWarning: (methodName: string) => {\n            logger.error(`You must initialize PostHog before calling ${methodName}`)\n        },\n\n        createLogger: (additionalPrefix: string, options?: CreateLoggerOptions) =>\n            _createLogger(`${prefix} ${additionalPrefix}`, options),\n    }\n    return logger\n}\n\nexport const logger = _createLogger('[PostHog.js]')\n\nexport const createLogger = logger.createLogger\n","import { each, find } from './utils'\nimport Config from './config'\nimport { Compression, RequestWithOptions, RequestResponse } from './types'\nimport { formDataToQuery } from './utils/request-utils'\n\nimport { logger } from './utils/logger'\nimport { AbortController, fetch, navigator, XMLHttpRequest } from './utils/globals'\nimport { gzipSync, strToU8 } from 'fflate'\n\nimport { _base64Encode } from './utils/encode-utils'\n\n// eslint-disable-next-line compat/compat\nexport const SUPPORTS_REQUEST = !!XMLHttpRequest || !!fetch\n\nconst CONTENT_TYPE_PLAIN = 'text/plain'\nconst CONTENT_TYPE_JSON = 'application/json'\nconst CONTENT_TYPE_FORM = 'application/x-www-form-urlencoded'\nconst SIXTY_FOUR_KILOBYTES = 64 * 1024\n/*\n fetch will fail if we request keepalive with a body greater than 64kb\n sets the threshold lower than that so that\n any overhead doesn't push over the threshold after checking here\n*/\nconst KEEP_ALIVE_THRESHOLD = SIXTY_FOUR_KILOBYTES * 0.8\ntype EncodedBody = {\n    contentType: string\n    body: string | BlobPart\n    estimatedSize: number\n}\n\n/**\n * Extends a URL with additional query parameters\n * @param url - The URL to extend\n * @param params - The parameters to add\n * @param replace - When true (default), new params overwrite existing ones with same key. When false, existing params are preserved.\n * @returns The URL with extended parameters\n */\nexport const extendURLParams = (url: string, params: Record<string, any>, replace: boolean = true): string => {\n    const [baseUrl, search] = url.split('?')\n    const newParams = { ...params }\n\n    const updatedSearch =\n        search?.split('&').map((pair) => {\n            const [key, origValue] = pair.split('=')\n            const value = replace ? (newParams[key] ?? origValue) : origValue\n            delete newParams[key]\n            return `${key}=${value}`\n        }) ?? []\n\n    const remaining = formDataToQuery(newParams)\n    if (remaining) {\n        updatedSearch.push(remaining)\n    }\n\n    return `${baseUrl}?${updatedSearch.join('&')}`\n}\n\nexport const jsonStringify = (data: any, space?: string | number): string => {\n    // With plain JSON.stringify, we get an exception when a property is a BigInt. This has caused problems for some users,\n    // see https://github.com/PostHog/posthog-js/issues/1440\n    // To work around this, we convert BigInts to strings before stringifying the data. This is not ideal, as we lose\n    // information that this was originally a number, but given ClickHouse doesn't support BigInts, the customer\n    // would not be able to operate on these numerically anyway.\n    return JSON.stringify(data, (_, value) => (typeof value === 'bigint' ? value.toString() : value), space)\n}\n\nconst encodeToDataString = (data: string | Record<string, any>): string => {\n    return 'data=' + encodeURIComponent(typeof data === 'string' ? data : jsonStringify(data))\n}\n\nconst encodePostData = ({ data, compression }: RequestWithOptions): EncodedBody | undefined => {\n    if (!data) {\n        return\n    }\n\n    if (compression === Compression.GZipJS) {\n        const gzipData = gzipSync(strToU8(jsonStringify(data)), { mtime: 0 })\n        const blob = new Blob([gzipData], { type: CONTENT_TYPE_PLAIN })\n        return {\n            contentType: CONTENT_TYPE_PLAIN,\n            body: blob,\n            estimatedSize: blob.size,\n        }\n    }\n\n    if (compression === Compression.Base64) {\n        const b64data = _base64Encode(jsonStringify(data))\n        const encodedBody = encodeToDataString(b64data)\n\n        return {\n            contentType: CONTENT_TYPE_FORM,\n            body: encodedBody,\n            estimatedSize: new Blob([encodedBody]).size,\n        }\n    }\n\n    const jsonBody = jsonStringify(data)\n    return {\n        contentType: CONTENT_TYPE_JSON,\n        body: jsonBody,\n        estimatedSize: new Blob([jsonBody]).size,\n    }\n}\n\nconst xhr = (options: RequestWithOptions) => {\n    const req = new XMLHttpRequest!()\n    req.open(options.method || 'GET', options.url, true)\n    const { contentType, body } = encodePostData(options) ?? {}\n\n    each(options.headers, function (headerValue, headerName) {\n        req.setRequestHeader(headerName, headerValue)\n    })\n\n    if (contentType) {\n        req.setRequestHeader('Content-Type', contentType)\n    }\n\n    if (options.timeout) {\n        req.timeout = options.timeout\n    }\n    if (!options.disableXHRCredentials) {\n        // send the ph_optout cookie\n        // withCredentials cannot be modified until after calling .open on Android and Mobile Safari\n        req.withCredentials = true\n    }\n    req.onreadystatechange = () => {\n        // XMLHttpRequest.DONE == 4, except in safari 4\n        if (req.readyState === 4) {\n            const response: RequestResponse = {\n                statusCode: req.status,\n                text: req.responseText,\n            }\n            if (req.status === 200) {\n                try {\n                    response.json = JSON.parse(req.responseText)\n                } catch {\n                    // logger.error(e)\n                }\n            }\n\n            options.callback?.(response)\n        }\n    }\n    req.send(body)\n}\n\nconst _fetch = (options: RequestWithOptions) => {\n    const { contentType, body, estimatedSize } = encodePostData(options) ?? {}\n\n    // eslint-disable-next-line compat/compat\n    const headers = new Headers()\n    each(options.headers, function (headerValue, headerName) {\n        headers.append(headerName, headerValue)\n    })\n\n    if (contentType) {\n        headers.append('Content-Type', contentType)\n    }\n\n    const url = options.url\n    let aborter: { signal: any; timeout: ReturnType<typeof setTimeout> } | null = null\n\n    if (AbortController) {\n        const controller = new AbortController()\n        aborter = {\n            signal: controller.signal,\n            timeout: setTimeout(() => controller.abort(), options.timeout),\n        }\n    }\n\n    fetch!(url, {\n        method: options?.method || 'GET',\n        headers,\n        // if body is greater than 64kb, then fetch with keepalive will error\n        // see 8:10:5 at https://fetch.spec.whatwg.org/#http-network-or-cache-fetch,\n        // but we do want to set keepalive sometimes as it can  help with success\n        // when e.g. a page is being closed\n        // so let's get the best of both worlds and only set keepalive for POST requests\n        // where the body is less than 64kb\n        // NB this is fetch keepalive and not http keepalive\n        keepalive: options.method === 'POST' && (estimatedSize || 0) < KEEP_ALIVE_THRESHOLD,\n        body,\n        signal: aborter?.signal,\n        ...options.fetchOptions,\n    })\n        .then((response) => {\n            return response.text().then((responseText) => {\n                const res: RequestResponse = {\n                    statusCode: response.status,\n                    text: responseText,\n                }\n\n                if (response.status === 200) {\n                    try {\n                        res.json = JSON.parse(responseText)\n                    } catch (e) {\n                        logger.error(e)\n                    }\n                }\n\n                options.callback?.(res)\n            })\n        })\n        .catch((error) => {\n            logger.error(error)\n            options.callback?.({ statusCode: 0, text: error })\n        })\n        .finally(() => (aborter ? clearTimeout(aborter.timeout) : null))\n\n    return\n}\n\nconst _sendBeacon = (options: RequestWithOptions) => {\n    // beacon documentation https://w3c.github.io/beacon/\n    // beacons format the message and use the type property\n\n    const url = extendURLParams(options.url, {\n        beacon: '1',\n    })\n\n    try {\n        const { contentType, body } = encodePostData(options) ?? {}\n        // sendBeacon requires a blob so we convert it\n        const sendBeaconBody = typeof body === 'string' ? new Blob([body], { type: contentType }) : body\n        navigator!.sendBeacon!(url, sendBeaconBody)\n    } catch {\n        // send beacon is a best-effort, fire-and-forget mechanism on page unload,\n        // we don't want to throw errors here\n    }\n}\n\nconst AVAILABLE_TRANSPORTS: {\n    transport: RequestWithOptions['transport']\n    method: (options: RequestWithOptions) => void\n}[] = []\n\n// We add the transports in order of preference\nif (fetch) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'fetch',\n        method: _fetch,\n    })\n}\n\nif (XMLHttpRequest) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'XHR',\n        method: xhr,\n    })\n}\n\nif (navigator?.sendBeacon) {\n    AVAILABLE_TRANSPORTS.push({\n        transport: 'sendBeacon',\n        method: _sendBeacon,\n    })\n}\n\n// This is the entrypoint. It takes care of sanitizing the options and then calls the appropriate request method.\nexport const request = (_options: RequestWithOptions) => {\n    // Clone the options so we don't modify the original object\n    const options = { ..._options }\n    options.timeout = options.timeout || 60000\n\n    options.url = extendURLParams(options.url, {\n        _: new Date().getTime().toString(),\n        ver: Config.LIB_VERSION,\n        compression: options.compression,\n    })\n\n    const transport = options.transport ?? 'fetch'\n\n    const availableTransports = AVAILABLE_TRANSPORTS.filter(\n        (t) => !options.disableTransport || !t.transport || !options.disableTransport.includes(t.transport)\n    )\n\n    const transportMethod =\n        find(availableTransports, (t) => t.transport === transport)?.method ?? availableTransports[0].method\n\n    if (!transportMethod) {\n        throw new Error('No available transport method')\n    }\n\n    transportMethod(options)\n}\n","import { ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS, ERROR_TRACKING_SUPPRESSION_RULES } from './constants'\nimport { PostHog } from './posthog-core'\nimport { CaptureResult, ErrorTrackingSuppressionRule, Properties, RemoteConfig } from './types'\nimport { createLogger } from './utils/logger'\nimport { propertyComparisons } from './utils/property-utils'\nimport { isString, isArray, ErrorTracking, isNullish } from '@posthog/core'\n\nconst logger = createLogger('[Error tracking]')\n\nexport function buildErrorPropertiesBuilder() {\n    return new ErrorTracking.ErrorPropertiesBuilder(\n        [\n            new ErrorTracking.DOMExceptionCoercer(),\n            new ErrorTracking.PromiseRejectionEventCoercer(),\n            new ErrorTracking.ErrorEventCoercer(),\n            new ErrorTracking.ErrorCoercer(),\n            new ErrorTracking.EventCoercer(),\n            new ErrorTracking.ObjectCoercer(),\n            new ErrorTracking.StringCoercer(),\n            new ErrorTracking.PrimitiveCoercer(),\n        ],\n        ErrorTracking.createStackParser(\n            'web:javascript',\n            ErrorTracking.chromeStackLineParser,\n            ErrorTracking.geckoStackLineParser\n        )\n    )\n}\nexport class PostHogExceptions {\n    private readonly _instance: PostHog\n    private _suppressionRules: ErrorTrackingSuppressionRule[] = []\n    private _errorPropertiesBuilder: ErrorTracking.ErrorPropertiesBuilder = buildErrorPropertiesBuilder()\n\n    constructor(instance: PostHog) {\n        this._instance = instance\n        this._suppressionRules = this._instance.persistence?.get_property(ERROR_TRACKING_SUPPRESSION_RULES) ?? []\n    }\n\n    onRemoteConfig(response: RemoteConfig) {\n        const suppressionRules = response.errorTracking?.suppressionRules ?? []\n        const captureExtensionExceptions = response.errorTracking?.captureExtensionExceptions\n\n        // store this in-memory in case persistence is disabled\n        this._suppressionRules = suppressionRules\n\n        if (this._instance.persistence) {\n            this._instance.persistence.register({\n                [ERROR_TRACKING_SUPPRESSION_RULES]: this._suppressionRules,\n                [ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS]: captureExtensionExceptions,\n            })\n        }\n    }\n\n    private get _captureExtensionExceptions() {\n        const enabled_server_side = !!this._instance.get_property(ERROR_TRACKING_CAPTURE_EXTENSION_EXCEPTIONS)\n        const enabled_client_side = this._instance.config.error_tracking.captureExtensionExceptions\n        return enabled_client_side ?? enabled_server_side ?? false\n    }\n\n    buildProperties(\n        input: unknown,\n        metadata?: { handled?: boolean; syntheticException?: Error }\n    ): ErrorTracking.ErrorProperties {\n        return this._errorPropertiesBuilder.buildFromUnknown(input, {\n            syntheticException: metadata?.syntheticException,\n            mechanism: {\n                handled: metadata?.handled,\n            },\n        })\n    }\n\n    sendExceptionEvent(properties: Properties): CaptureResult | undefined {\n        const exceptionList = properties.$exception_list\n\n        if (this._isExceptionList(exceptionList)) {\n            if (this._matchesSuppressionRule(exceptionList)) {\n                logger.info('Skipping exception capture because a suppression rule matched')\n                return\n            }\n\n            if (!this._captureExtensionExceptions && this._isExtensionException(exceptionList)) {\n                logger.info('Skipping exception capture because it was thrown by an extension')\n                return\n            }\n\n            if (\n                !this._instance.config.error_tracking.__capturePostHogExceptions &&\n                this._isPostHogException(exceptionList)\n            ) {\n                logger.info('Skipping exception capture because it was thrown by the PostHog SDK')\n                return\n            }\n        }\n\n        return this._instance.capture('$exception', properties, {\n            _noTruncate: true,\n            _batchKey: 'exceptionEvent',\n        })\n    }\n\n    private _matchesSuppressionRule(exceptionList: ErrorTracking.ExceptionList): boolean {\n        if (exceptionList.length === 0) {\n            return false\n        }\n\n        const exceptionValues = exceptionList.reduce(\n            (acc, { type, value }) => {\n                if (isString(type) && type.length > 0) {\n                    acc['$exception_types'].push(type)\n                }\n                if (isString(value) && value.length > 0) {\n                    acc['$exception_values'].push(value)\n                }\n                return acc\n            },\n            {\n                $exception_types: [] as string[],\n                $exception_values: [] as string[],\n            }\n        )\n\n        return this._suppressionRules.some((rule) => {\n            const results = rule.values.map((v) => {\n                const compare = propertyComparisons[v.operator]\n                const targets = isArray(v.value) ? v.value : [v.value]\n                const values = exceptionValues[v.key] ?? []\n                return targets.length > 0 ? compare(targets, values) : false\n            })\n            return rule.type === 'OR' ? results.some(Boolean) : results.every(Boolean)\n        })\n    }\n\n    private _isExtensionException(exceptionList: ErrorTracking.ExceptionList): boolean {\n        const frames = exceptionList.flatMap((e) => e.stacktrace?.frames ?? [])\n        return frames.some((f) => f.filename && f.filename.startsWith('chrome-extension://'))\n    }\n\n    private _isPostHogException(exceptionList: ErrorTracking.ExceptionList): boolean {\n        if (exceptionList.length > 0) {\n            const exception = exceptionList[0]\n            const frames = exception.stacktrace?.frames ?? []\n            const lastFrame = frames[frames.length - 1]\n            return lastFrame?.filename?.includes('posthog.com/static') ?? false\n        }\n\n        return false\n    }\n\n    private _isExceptionList(candidate: unknown): candidate is ErrorTracking.ExceptionList {\n        return !isNullish(candidate) && isArray(candidate)\n    }\n}\n","import { assignableWindow, window } from '../utils/globals'\nimport { ErrorEventArgs } from '../types'\nimport { createLogger } from '../utils/logger'\nimport type { ErrorTracking } from '@posthog/core'\nimport { buildErrorPropertiesBuilder } from '../posthog-exceptions'\n\nconst logger = createLogger('[ExceptionAutocapture]')\nconst errorPropertiesBuilder = buildErrorPropertiesBuilder()\n\nconst wrapOnError = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const win = window as any\n    if (!win) {\n        logger.info('window not available, cannot wrap onerror')\n    }\n    const originalOnError = win.onerror\n\n    win.onerror = function (...args: ErrorEventArgs): boolean {\n        const error = args[4]\n        const event = args[0]\n        const errorProperties = errorPropertiesBuilder.buildFromUnknown(error || event, {\n            mechanism: { handled: false },\n        })\n        captureFn(errorProperties)\n        return originalOnError?.(...args) ?? false\n    }\n    win.onerror.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete win.onerror?.__POSTHOG_INSTRUMENTED__\n        win.onerror = originalOnError\n    }\n}\n\nconst wrapUnhandledRejection = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const win = window as any\n    if (!win) {\n        logger.info('window not available, cannot wrap onUnhandledRejection')\n    }\n\n    const originalOnUnhandledRejection = win.onunhandledrejection\n\n    win.onunhandledrejection = function (ev: PromiseRejectionEvent): boolean {\n        const errorProperties = errorPropertiesBuilder.buildFromUnknown(ev, {\n            mechanism: { handled: false },\n        })\n        captureFn(errorProperties)\n        return originalOnUnhandledRejection?.apply(win, [ev]) ?? false\n    }\n    win.onunhandledrejection.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete win.onunhandledrejection?.__POSTHOG_INSTRUMENTED__\n        win.onunhandledrejection = originalOnUnhandledRejection\n    }\n}\n\nconst wrapConsoleError = (captureFn: (props: ErrorTracking.ErrorProperties) => void) => {\n    const con = console as any\n    if (!con) {\n        logger.info('console not available, cannot wrap console.error')\n    }\n\n    const originalConsoleError = con.error\n\n    con.error = function (...args: any[]): void {\n        const event = args.join(' ')\n        const error = args.find((arg) => arg instanceof Error)\n        const errorProperties = errorPropertiesBuilder.buildFromUnknown(error || event, {\n            mechanism: { handled: false },\n            syntheticException: new Error('PostHog syntheticException'),\n        })\n        captureFn(errorProperties)\n        return originalConsoleError?.(...args)\n    }\n    con.error.__POSTHOG_INSTRUMENTED__ = true\n\n    return () => {\n        delete con.error?.__POSTHOG_INSTRUMENTED__\n        con.error = originalConsoleError\n    }\n}\n\nconst posthogErrorWrappingFunctions = {\n    wrapOnError,\n    wrapUnhandledRejection,\n    wrapConsoleError,\n}\n\nassignableWindow.__PosthogExtensions__ = assignableWindow.__PosthogExtensions__ || {}\nassignableWindow.__PosthogExtensions__.errorWrappingFunctions = posthogErrorWrappingFunctions\n\n// we used to put these on window, and now we put them on __PosthogExtensions__\n// but that means that old clients which lazily load this extension are looking in the wrong place\n// yuck,\n// so we also put them directly on the window\n// when 1.161.1 is the oldest version seen in production we can remove this\nassignableWindow.posthogErrorWrappingFunctions = posthogErrorWrappingFunctions\n\nexport default posthogErrorWrappingFunctions\n"],"names":["win","window","undefined","global","globalThis","self","File","navigator","document","location","fetch","XMLHttpRequest","AbortController","userAgent","assignableWindow","nativeIsArray","Array","isArray","type_utils_toString","Object","prototype","toString","obj","call","isUndefined","x","isString","isPrimitive","value","isBuiltin","candidate","className","isEvent","Event","base","_unused","isInstanceOf","parsedStackResults","lastKeysCount","cachedFilenameChunkIds","getFilenameToChunkIdMap","stackParser","chunkIdMap","_posthogChunkIds","chunkIdKeys","keys","length","reduce","acc","stackKey","result","parsedStack","i","stackFrame","filename","chunkId","ErrorPropertiesBuilder","constructor","coercers","modifiers","this","buildFromUnknown","input","hint","mechanism","handled","type","exceptionWithCause","buildCoercingContext","apply","parsingContext","buildParsingContext","exceptionWithStack","parseStacktrace","$exception_list","convertToExceptionList","$exception_level","modifyFrames","exceptionList","_this","_asyncToGenerator","exc","stacktrace","frames","applyModifiers","coerceFallback","ctx","_ctx$syntheticExcepti","stack","syntheticException","synthetic","err","cause","applyChunkIds","_extends","map","frame","chunk_id","applyCoercers","adapter","match","coerce","_this2","newFrames","modifier","_mechanism$type","_mechanism$handled","_exceptionWithStack$s","currentException","push","depth","next","UNKNOWN_FUNCTION","createFrame","platform","func","lineno","colno","function","in_app","extractSafariExtensionDetails","isSafariExtension","indexOf","isSafariWebExtension","split","chromeRegexNoFnName","chromeRegex","chromeEvalRegex","chromeStackLineParser","line","noFnParts","exec","col","parts","subMatch","geckoREgex","geckoEvalRegex","geckoStackLineParser","WEBPACK_ERROR_REGEXP","STACKTRACE_FRAME_LIMIT","createStackParser","_len","arguments","parsers","_key","skipFirstLines","lines","cleanedLine","test","replace","parser","localStack","from","reverse","slice","arr","reverseAndStripFrames","DOMExceptionCoercer","isDOMException","isDOMError","hasStack","getType","getValue","name","message","ErrorCoercer","Error","getMessage","getStack","_ctx","error","String","ErrorEventCoercer","exceptionLike","ERROR_TYPES_PATTERN","StringCoercer","getInfos","groups","severityLevels","extractExceptionKeysForMessage","maxLength","sort","serialized","join","ObjectCoercer","errorProperty","getErrorPropertyFromObject","level","isSeverityLevel","getObjectClassName","trim","isEmptyString","prop","hasOwnProperty","getPrototypeOf","e","EventCoercer","evt","constructorName","PrimitiveCoercer","PromiseRejectionEventCoercer","reason","getUnhandledRejectionReason","detail","_createLogger","prefix","_temp","debugEnabled","logger","_log","POSTHOG_DEBUG","console","consoleLog","args","info","_len2","_key2","warn","_len3","_key3","_len4","_key4","critical","_len5","_key5","uninitializedWarning","methodName","createLogger","additionalPrefix","options","sendBeacon","errorPropertiesBuilder","ErrorTracking","posthogErrorWrappingFunctions","wrapOnError","captureFn","originalOnError","onerror","_originalOnError","event","errorProperties","__POSTHOG_INSTRUMENTED__","_win$onerror","wrapUnhandledRejection","originalOnUnhandledRejection","onunhandledrejection","ev","_originalOnUnhandledR","_win$onunhandledrejec","wrapConsoleError","con","originalConsoleError","find","arg","_con$error","__PosthogExtensions__","errorWrappingFunctions"],"mappings":"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"}