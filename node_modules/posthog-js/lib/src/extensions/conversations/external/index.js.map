{"version":3,"file":"index.js","sourceRoot":"","sources":["../../../../../src/extensions/conversations/external/index.tsx"],"names":[],"mappings":"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","sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-unused-vars\nimport { render, h } from 'preact'\nimport { isNumber } from '@posthog/core'\nimport {\n    ConversationsRemoteConfig,\n    ConversationsWidgetState,\n    UserProvidedTraits,\n    SendMessageResponse,\n    GetMessagesResponse,\n    MarkAsReadResponse,\n} from '../../../posthog-conversations-types'\nimport { PostHog } from '../../../posthog-core'\nimport { ConversationsManager as ConversationsManagerInterface } from '../posthog-conversations'\nimport { ConversationsPersistence } from './persistence'\nimport { ConversationsWidget } from './components/ConversationsWidget'\nimport { createLogger } from '../../../utils/logger'\nimport { document, window } from '../../../utils/globals'\nimport { formDataToQuery } from '../../../utils/request-utils'\n\nconst logger = createLogger('[ConversationsManager]')\n\nconst WIDGET_CONTAINER_ID = 'ph-conversations-widget-container'\nconst POLL_INTERVAL_MS = 5000 // 5 seconds\n\nexport class ConversationsManager implements ConversationsManagerInterface {\n    private _config: ConversationsRemoteConfig\n    private _persistence: ConversationsPersistence\n    private _widgetRef: ConversationsWidget | null = null\n    private _containerElement: HTMLDivElement | null = null\n    private _currentTicketId: string | null = null\n    private _pollIntervalId: number | null = null\n    private _lastMessageTimestamp: string | null = null\n    private _isPolling: boolean = false\n    private _unsubscribeIdentifyListener: (() => void) | null = null\n    private _unreadCount: number = 0\n    // SECURITY: widget_session_id is the key for access control\n    // This is a random UUID that only this browser knows\n    private _widgetSessionId: string\n\n    constructor(\n        config: ConversationsRemoteConfig,\n        private readonly _posthog: PostHog\n    ) {\n        this._config = config\n        this._persistence = new ConversationsPersistence(_posthog)\n        // Get or create widget_session_id - this stays the same even when user identifies\n        this._widgetSessionId = this._persistence.getOrCreateWidgetSessionId()\n\n        logger.info('ConversationsManager initialized', {\n            config,\n            widgetSessionId: this._widgetSessionId,\n        })\n\n        this._initialize()\n    }\n\n    /** Send a message via the API */\n    private _apiSendMessage(\n        message: string,\n        ticketId: string | undefined,\n        userTraits?: UserProvidedTraits\n    ): Promise<SendMessageResponse> {\n        const token = this._config.token\n\n        // eslint-disable-next-line compat/compat\n        return new Promise((resolve, reject) => {\n            const distinctId = this._posthog.get_distinct_id()\n            const personProperties = this._posthog.persistence?.props || {}\n\n            // Priority for traits:\n            // 1. User-provided traits from the widget form\n            // 2. PostHog person properties\n            const name = userTraits?.name || personProperties.$name || personProperties.name || null\n            const email = userTraits?.email || personProperties.$email || personProperties.email || null\n\n            const payload = {\n                widget_session_id: this._widgetSessionId,\n                // distinct_id is only used for Person linking, not access control\n                distinct_id: distinctId,\n                message: message.trim(),\n                traits: {\n                    name,\n                    email,\n                },\n                ticket_id: ticketId || null,\n            }\n\n            this._posthog._send_request({\n                url: this._posthog.requestRouter.endpointFor('api', '/api/conversations/v1/widget/message'),\n                method: 'POST',\n                data: payload,\n                headers: {\n                    'X-Conversations-Token': token,\n                },\n                callback: (response) => {\n                    if (response.statusCode === 429) {\n                        reject(new Error('Too many requests. Please wait before trying again.'))\n                        return\n                    }\n\n                    if (response.statusCode !== 200 && response.statusCode !== 201) {\n                        const errorMsg = response.json?.detail || response.json?.message || 'Failed to send message'\n                        logger.error('Failed to send message', { status: response.statusCode })\n                        reject(new Error(errorMsg))\n                        return\n                    }\n\n                    if (!response.json) {\n                        reject(new Error('Invalid response from server'))\n                        return\n                    }\n\n                    const data = response.json as SendMessageResponse\n                    resolve(data)\n                },\n            })\n        })\n    }\n\n    /** Fetch messages via the API */\n    private _apiGetMessages(ticketId: string, after?: string): Promise<GetMessagesResponse> {\n        const token = this._config.token\n\n        // eslint-disable-next-line compat/compat\n        return new Promise((resolve, reject) => {\n            // SECURITY: widget_session_id is required for access control\n            // distinct_id is NOT sent for getMessages - access is controlled by widget_session_id only\n            const queryParams: Record<string, string> = {\n                widget_session_id: this._widgetSessionId,\n                limit: '50',\n            }\n\n            if (after) {\n                queryParams.after = after\n            }\n\n            this._posthog._send_request({\n                url: this._posthog.requestRouter.endpointFor(\n                    'api',\n                    `/api/conversations/v1/widget/messages/${ticketId}?${formDataToQuery(queryParams)}`\n                ),\n                method: 'GET',\n                headers: {\n                    'X-Conversations-Token': token,\n                },\n                callback: (response) => {\n                    if (response.statusCode === 429) {\n                        reject(new Error('Too many requests. Please wait before trying again.'))\n                        return\n                    }\n\n                    if (response.statusCode !== 200) {\n                        const errorMsg = response.json?.detail || response.json?.message || 'Failed to fetch messages'\n                        logger.error('Failed to fetch messages', { status: response.statusCode })\n                        reject(new Error(errorMsg))\n                        return\n                    }\n\n                    if (!response.json) {\n                        reject(new Error('Invalid response from server'))\n                        return\n                    }\n\n                    const data = response.json as GetMessagesResponse\n                    resolve(data)\n                },\n            })\n        })\n    }\n\n    /** Mark messages as read via the API */\n    private _apiMarkAsRead(ticketId: string): Promise<MarkAsReadResponse> {\n        const token = this._config.token\n\n        // eslint-disable-next-line compat/compat\n        return new Promise((resolve, reject) => {\n            logger.info('Marking messages as read', { ticketId })\n\n            this._posthog._send_request({\n                url: this._posthog.requestRouter.endpointFor(\n                    'api',\n                    `/api/conversations/v1/widget/messages/${ticketId}/read`\n                ),\n                method: 'POST',\n                data: {\n                    widget_session_id: this._widgetSessionId,\n                },\n                headers: {\n                    'X-Conversations-Token': token,\n                },\n                callback: (response) => {\n                    if (response.statusCode === 429) {\n                        reject(new Error('Too many requests. Please wait before trying again.'))\n                        return\n                    }\n\n                    if (response.statusCode !== 200) {\n                        const errorMsg =\n                            response.json?.detail || response.json?.message || 'Failed to mark messages as read'\n                        logger.error('Failed to mark messages as read', { status: response.statusCode })\n                        reject(new Error(errorMsg))\n                        return\n                    }\n\n                    if (!response.json) {\n                        reject(new Error('Invalid response from server'))\n                        return\n                    }\n\n                    const data = response.json as MarkAsReadResponse\n                    resolve(data)\n                },\n            })\n        })\n    }\n\n    /**\n     * Initialize the widget\n     */\n    private _initialize(): void {\n        if (!document || !window) {\n            logger.info('Conversations not available: Document or window not available')\n            return\n        }\n\n        // Load any existing ticket ID from localStorage\n        this._currentTicketId = this._persistence.loadTicketId()\n        logger.info('Loaded ticket ID from storage', { ticketId: this._currentTicketId })\n\n        const savedState = this._persistence.loadWidgetState()\n        let initialState: ConversationsWidgetState = 'closed'\n        if (savedState === 'open') {\n            initialState = 'open'\n        }\n\n        // Get initial user traits (from PostHog person properties or saved)\n        const initialUserTraits = this._getInitialUserTraits()\n\n        // Render the widget\n        this._renderWidget(initialState, initialUserTraits)\n\n        // Track widget initialization\n        this._posthog.capture('$conversations_widget_loaded', {\n            hasExistingTicket: !!this._currentTicketId,\n            initialState: initialState,\n            hasUserTraits: !!initialUserTraits,\n        })\n\n        // If we have a ticket, load its messages\n        if (this._currentTicketId) {\n            this._loadMessages()\n        }\n\n        // Start polling for messages (always, to show unread badge)\n        this._startPolling()\n\n        // Listen for identify events to handle distinct_id changes\n        this._setupIdentifyListener()\n    }\n\n    /**\n     * Get initial user traits from PostHog or localStorage\n     */\n    private _getInitialUserTraits(): UserProvidedTraits | null {\n        // First, check PostHog's person properties\n        const personProperties = this._posthog.persistence?.props || {}\n        const posthogName = personProperties.$name || personProperties.name\n        const posthogEmail = personProperties.$email || personProperties.email\n\n        // If we have traits from PostHog, use those\n        if (posthogName || posthogEmail) {\n            return {\n                name: posthogName || undefined,\n                email: posthogEmail || undefined,\n            }\n        }\n\n        // Otherwise, check localStorage for previously saved traits\n        const savedTraits = this._persistence.loadUserTraits()\n        if (savedTraits && (savedTraits.name || savedTraits.email)) {\n            return savedTraits\n        }\n\n        return null\n    }\n\n    /**\n     * Handle user identification from the widget form\n     */\n    private _handleIdentify = (traits: UserProvidedTraits): void => {\n        // Save traits to localStorage\n        this._persistence.saveUserTraits(traits)\n\n        // Track identification\n        this._posthog.capture('$conversations_user_identified', {\n            hasName: !!traits.name,\n            hasEmail: !!traits.email,\n        })\n    }\n\n    /**\n     * Handle sending a message\n     */\n    private _handleSendMessage = async (message: string): Promise<void> => {\n        // Get user traits from the widget\n        const userTraits = this._widgetRef?.getUserTraits() || undefined\n\n        const isNewTicket = !this._currentTicketId\n\n        try {\n            // Call API directly\n            const response = await this._apiSendMessage(message, this._currentTicketId || undefined, userTraits)\n\n            // Update current ticket ID\n            if (!this._currentTicketId) {\n                this._currentTicketId = response.ticket_id\n                this._persistence.saveTicketId(response.ticket_id)\n                logger.info('New ticket created', { ticketId: response.ticket_id })\n            }\n\n            // Track message sent\n            this._posthog.capture('$conversations_message_sent', {\n                ticketId: response.ticket_id,\n                isNewTicket: isNewTicket,\n                messageLength: message.length,\n            })\n\n            // Update last message timestamp\n            this._lastMessageTimestamp = response.created_at\n\n            // Poll for response immediately\n            setTimeout(() => this._pollMessages(), 1000)\n        } catch (error) {\n            logger.error('Failed to send message', error)\n            throw error\n        }\n    }\n\n    /**\n     * Handle widget state changes\n     */\n    private _handleStateChange = (state: ConversationsWidgetState): void => {\n        logger.info('Widget state changed', { state })\n\n        // Track state changes\n        this._posthog.capture('$conversations_widget_state_changed', {\n            state: state,\n            ticketId: this._currentTicketId,\n        })\n\n        // Save state to localStorage\n        this._persistence.saveWidgetState(state)\n\n        // Mark messages as read when widget opens\n        if (state === 'open') {\n            if (this._unreadCount > 0 && this._currentTicketId) {\n                this._markMessagesAsRead()\n            }\n        }\n    }\n\n    /**\n     * Mark messages as read\n     */\n    private async _markMessagesAsRead(): Promise<void> {\n        if (!this._currentTicketId) {\n            return\n        }\n\n        try {\n            const response = await this._apiMarkAsRead(this._currentTicketId)\n            this._unreadCount = response.unread_count\n            // Update the widget to reflect the new unread count\n            this._widgetRef?.setUnreadCount(0)\n            logger.info('Messages marked as read', { unreadCount: response.unread_count })\n        } catch (error) {\n            logger.error('Failed to mark messages as read', error)\n        }\n    }\n\n    /**\n     * Load messages for the current ticket\n     */\n    private async _loadMessages(): Promise<void> {\n        if (!this._currentTicketId) {\n            return\n        }\n\n        try {\n            const response = await this._apiGetMessages(this._currentTicketId, this._lastMessageTimestamp || undefined)\n\n            // Update unread count from response\n            if (isNumber(response.unread_count)) {\n                this._unreadCount = response.unread_count\n                this._widgetRef?.setUnreadCount(response.unread_count)\n\n                // If widget is open and there are unread messages, mark them as read\n                if (response.unread_count > 0 && this._isWidgetOpen()) {\n                    this._markMessagesAsRead()\n                }\n            }\n\n            if (response.messages.length > 0) {\n                this._widgetRef?.addMessages(response.messages)\n                // Update last message timestamp\n                const lastMessage = response.messages[response.messages.length - 1]\n                this._lastMessageTimestamp = lastMessage.created_at\n            }\n        } catch (error) {\n            logger.error('Failed to load messages', error)\n        }\n    }\n\n    /**\n     * Check if the widget is currently open\n     */\n    private _isWidgetOpen(): boolean {\n        return this._persistence.loadWidgetState() === 'open'\n    }\n\n    /**\n     * Poll for new messages\n     */\n    private _pollMessages = async (): Promise<void> => {\n        if (this._isPolling || !this._currentTicketId) {\n            return\n        }\n\n        this._isPolling = true\n        try {\n            await this._loadMessages()\n        } finally {\n            this._isPolling = false\n        }\n    }\n\n    /**\n     * Start polling for new messages\n     */\n    private _startPolling(): void {\n        if (this._pollIntervalId) {\n            return // Already polling\n        }\n\n        // Poll immediately\n        this._pollMessages()\n\n        // Set up interval\n        this._pollIntervalId = window?.setInterval(() => {\n            this._pollMessages()\n        }, POLL_INTERVAL_MS) as unknown as number\n\n        logger.info('Started polling for messages')\n    }\n\n    /**\n     * Stop polling for new messages\n     */\n    private _stopPolling(): void {\n        if (this._pollIntervalId) {\n            window?.clearInterval(this._pollIntervalId)\n            this._pollIntervalId = null\n            logger.info('Stopped polling for messages')\n        }\n    }\n\n    /**\n     * Setup listener for identify events to handle distinct_id changes\n     */\n    private _setupIdentifyListener(): void {\n        // Listen for captured events and detect $identify events\n        this._unsubscribeIdentifyListener = this._posthog.on('eventCaptured', (event: any) => {\n            if (event.event === '$identify') {\n                const newDistinctId = event.properties?.distinct_id\n                const oldDistinctId = event.properties?.$anon_distinct_id\n\n                if (oldDistinctId && newDistinctId && oldDistinctId !== newDistinctId) {\n                    logger.info('Detected identify event', { oldDistinctId, newDistinctId })\n                    this._handleDistinctIdChange(oldDistinctId, newDistinctId)\n                }\n            }\n        })\n    }\n\n    /**\n     * Handle distinct_id changes when user identifies.\n     * The user continues their conversation seamlessly - widget_session_id stays the same.\n     * No migration needed since tickets are keyed by widget_session_id, not distinct_id.\n     * Backend will update ticket.distinct_id for Person linking on the next message.\n     */\n    private _handleDistinctIdChange(oldDistinctId: string, newDistinctId: string): void {\n        // No migration needed - widget_session_id stays the same\n        // The user keeps access to their ticket because the widget_session_id hasn't changed\n        logger.info('User identified, conversation continues with same widget_session_id', {\n            ticketId: this._currentTicketId,\n            widgetSessionId: this._widgetSessionId,\n            oldDistinctId,\n            newDistinctId,\n        })\n\n        // Track the identity change\n        this._posthog.capture('$conversations_identity_changed', {\n            hadExistingTicket: !!this._currentTicketId,\n        })\n    }\n\n    /**\n     * Enable/show the widget (button and chat panel)\n     */\n    enable(): void {\n        this._widgetRef?.show()\n    }\n\n    /**\n     * Disable/hide the widget completely (button and chat panel)\n     */\n    disable(): void {\n        this._widgetRef?.hide()\n    }\n\n    /**\n     * Send a message programmatically (internal use)\n     */\n    sendMessage(message: string): void {\n        this._handleSendMessage(message)\n    }\n\n    /**\n     * Clean up the widget\n     */\n    destroy(): void {\n        this._stopPolling()\n\n        // Unsubscribe from identify events\n        if (this._unsubscribeIdentifyListener) {\n            this._unsubscribeIdentifyListener()\n            this._unsubscribeIdentifyListener = null\n        }\n\n        if (this._containerElement) {\n            render(null, this._containerElement)\n            this._containerElement.remove()\n            this._containerElement = null\n        }\n\n        this._widgetRef = null\n        logger.info('Widget destroyed')\n    }\n\n    /**\n     * Reset all conversation data and destroy the widget.\n     * Called on posthog.reset() to start fresh.\n     */\n    reset(): void {\n        // Clear all persisted conversation data\n        this._persistence.clearAll()\n\n        // Reset local state\n        this._currentTicketId = null\n        this._lastMessageTimestamp = null\n        this._unreadCount = 0\n\n        // Destroy the widget\n        this.destroy()\n\n        logger.info('Conversations reset')\n    }\n\n    /**\n     * Render the widget to the DOM\n     */\n    private _renderWidget(initialState: ConversationsWidgetState, initialUserTraits: UserProvidedTraits | null): void {\n        if (!document) {\n            logger.info('Conversations widget not rendered: Document not available')\n            return\n        }\n\n        // Create container if it doesn't exist\n        let container = document.getElementById(WIDGET_CONTAINER_ID) as HTMLDivElement\n        if (!container) {\n            if (!document.body) {\n                logger.info('Conversations widget not rendered: Document body not available yet')\n                return\n            }\n            container = document.createElement('div')\n            container.id = WIDGET_CONTAINER_ID\n            document.body.appendChild(container)\n        }\n        this._containerElement = container\n\n        // Render widget with ref\n        render(\n            <ConversationsWidget\n                ref={(ref: ConversationsWidget | null) => {\n                    this._widgetRef = ref\n                }}\n                config={this._config}\n                initialState={initialState}\n                initialUserTraits={initialUserTraits}\n                onSendMessage={this._handleSendMessage}\n                onStateChange={this._handleStateChange}\n                onIdentify={this._handleIdentify}\n            />,\n            container\n        )\n    }\n}\n\n/**\n * Initialize the conversations widget\n * This is the entry point called from the lazy-loaded bundle\n */\nexport function initConversations(config: ConversationsRemoteConfig, posthog: PostHog): ConversationsManager {\n    logger.info('initConversations called', { hasConfig: !!config, hasPosthog: !!posthog })\n    return new ConversationsManager(config, posthog)\n}\n"]}